<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>SignalK Data Browser</title>
  <style>
	#data tr:nth-child(odd) { background-color: #f2f2f2; }
	#displayLabel td {vertical-align: top;; font-weight: bold}
	#displayValue td {text-align: center; vertical-align: middle; font-size: xx-large; font-weight: bold}
	#displayUnit td {text-align: center; vertical-align: middle;}
  </style>
</head>
<body>
  <pre>
	<div id="display"/>
  </pre>
  <pre>
	<div id="data"/>
  </pre>
  <pre>
	<div id="log"/>
  </pre>
</body>

<script>

//
// Marco Bergman 2021
// Configure your signalk url:port below, like openplotter.pypilot.org:3000 or 10.10.10.1:3000
//
var mySignalkURL = "192.168.178.37:3000"

var displayDiv = document.getElementById('display');
var dataDiv = document.getElementById('data');
var logDiv = document.getElementById('log');

var spinner ="◐◓◑◒"

// process http parameters
presentation = 'table'
parameter_pairs = window.location.search.slice(1).split("&")
parameter_pairs.forEach(function (item) {
	if (item.split("=")[0] == "presentation")
		presentation = item.split("=")[1]
})

function sortDictionary(dict) {
	// sort a dictionary based on the key
	var sorted = [];
	for(var key in dict) {
		sorted[sorted.length] = key;
	}
	sorted.sort();

	var tempDict = {};
	for(var i = 0; i < sorted.length; i++) {
		tempDict[sorted[i]] = dict[sorted[i]];
	}

	return tempDict;
}

function getKey(key, signalkData) {
	// based on the name of the key, get the constituents out of the signalkData and convert if needed
	myRow = signalkData[key];
	try {
		path = myRow['path']
		unit = units[path];  // resolve the units from the units dictionary that was derived from the schema file
		timestamp = myRow['timestamp'];
		source = myRow['source'];
		stale = Date.now() - timestamp > 5000 ? true : false;

		// get the value
		if (typeof(myRow['value']) != 'object')
			value = myRow['value'];
		else
			// show complex values as json
			value = JSON.stringify(myRow['value']);
			
		// convert odd units
		if (unit == 'rad') {
			value = Math.round (value / Math.PI * 180, 0);
			unit = 'deg';
		}
		if (unit == 'm/s') {
			value = (value * 3600 / 1852).toFixed(1);
			unit = 'kts';
		}
		if (unit == 'm') {
			value = (value / 1852).toFixed(2);
			unit = 'NM';
		}
		if (unit == 'K') {
					value = (value - 273.15).toFixed(2);
					unit = '°C';
		}
	}
	catch {
		return {}
	}
	
	return {path, unit, value, timestamp, source, stale}
}


function getValue(key, signalkData) {
	// Get only the value of a key
	let {path, unit, value, timestamp, source, stale} 
		= getKey(key, signalkData);
	if (! stale)
		return value;
	else
		return null;
}


function formatTimestamp(timestamp) {
	var date = new Date(timestamp)

	var hour = date.getHours();
	var min = date.getMinutes();
	var sec = date.getSeconds();
	
	hour = (hour < 10 ? "0" : "") + hour;
	min = (min < 10 ? "0" : "") + min;
	sec = (sec < 10 ? "0" : "") + sec;
	
	return hour + ":" + min + ":" + sec;
}


function printSignalkTable(signalkData) {
	// print the contents of a dictionary in the form of an HTML table
	var result = "<table border=0 width='100%'>";
	// sort the table first
	signalkData = sortDictionary(signalkData);
	
	//logDiv.innerHTML = JSON.stringify(signalkData, null, 2);

	for (key in signalkData) {
		
		let {path, unit, value, timestamp, source, stale} = getKey(key, signalkData)
		
		if (path != key) {
			result += "<tr>";
			result += "<td><a title='" + descriptions[path] + "'>" + path + "</a></td>";
			result += "<td>" + (stale ? "<strike>" : "") + value + "</td>";
			result += "<td>" + unit + "</td>";
			result += "<td>" + source + "</td>";
			result += "<td>" + formatTimestamp(timestamp) + "</td>";
			result += "</tr>";
		}
	}
	dataDiv.innerHTML = result + "</table>";
}


function printSignalkDisplay(signalkData) {
	// print the contents of a dictionary in the form of an HTML table
	function printCell (key, label) {
		let {path, unit, value, timestamp, source, stale} = getKey(key, signalkData)
		
		result += "<td><table border=0 width='100%'>";
		result += "<tr id='displayLabel'><td><a title='" + descriptions[path] + "'>" + label + "</a></td>";
		result += "<tr id='displayValue'><td>" + (stale ? "<strike> " : " ") + value + " </td>";
		result += "<tr id='displayUnit'><td>" + unit + "</td>";
		result += "</table></td>";
	}
	
	var result = "<table border=1 width='300'>";
	result += "<tr>";
	printCell('navigation.headingTrue', 'HDG');
	printCell('navigation.courseOverGroundTrue', 'COG');
	result += "</tr><tr>";
	printCell('navigation.speedThroughWater', 'STW');
	printCell('navigation.speedOverGround', 'SOG');
	result += "</tr><tr>";
	printCell('environment.wind.angleApparent', 'AWA');
	printCell('environment.wind.angleTrueWater', 'TWA');
	result += "</tr><tr>";
	printCell('environment.wind.speedApparent', 'AWS');
	printCell('environment.wind.speedTrue', 'TWS');
	result += "</tr><tr>";
	printCell('environment.wind.directionTrue', 'TWD');
	i = ~~(Date.now()/1000) % (spinner.length)
	result += ("<td align=center><h1>" + spinner[i] + "</td>")
	result += "</tr>";
	displayDiv.innerHTML = result + "</table>";
}


function printSignalkGauge(signalkData) {
	displayDiv.innerHTML = '<canvas id="myCanvas" width="900" height="900"></canvas>';
	var limit = 45;
	var canvas = document.getElementById("myCanvas");
	var ctx = canvas.getContext("2d");
	var radius = canvas.width / 2;
	ctx.translate(radius, radius);
	radius = radius * 0.90

	function Arc(from, to, offset, lineWidth, strokeStyle){
		ctx.beginPath();
		ctx.lineWidth = lineWidth;
		ctx.strokeStyle = strokeStyle;
		ctx.arc(0,0,radius + offset, from/180*Math.PI, to/180*Math.PI)
		ctx.stroke();
	}

	function drawHand(ctx, pos, length, fillStyle) {
		var width = radius/15;
		ctx.fillStyle = fillStyle;
		ctx.lineWidth = radius/20;
		ctx.lineCap = "round";
		ctx.rotate(pos/180*Math.PI);
		ctx.beginPath();
		ctx.moveTo(-width, 0);
		ctx.lineTo(width, 0);
		ctx.lineTo(0, -length);
		ctx.lineTo(-width, 0);
		ctx.fill();
		ctx.rotate(-pos/180*Math.PI);
	}

	function drawBug(ctx, pos) {
		// Draw heading bug, if BRG available
		ctx.rotate(pos/180*Math.PI);
		Arc(270-5, 270+5, 0, radius/8, "orange");
		ctx.rotate(-pos/180*Math.PI);
	}

	// Red arc
	Arc(270-limit,270, -radius/8, radius/4, "#FF0000");
	// Green arc
	Arc(270,270+limit, -radius/8, radius/4, "#00FF00");
	// Main Circle
	Arc(0,360,0, radius/30, "#000000");
	// Gauge ticks
	for (x=0; x<360; x+=10) {
			if (Math.round(x/30) == x/30) {
					Arc(x-1, x+1, -radius/12, radius/6, "#000000")
			} else {
					Arc(x-1, x+1, -radius/32, radius/16, "#000000")
			}
	}

	// Heading bug
	bearingTrue = getValue('navigation.courseRhumbline.nextPoint.bearingTrue', signalkData)
	if (bearingTrue) {
		headingTrue = getValue('navigation.headingTrue', signalkData)
		if (headingTrue) {
			bearingTrue = bearingTrue *180/Math.PI;
			drawBug (ctx, bearingTrue - headingTrue);
		}
	}

	// Get data
	angleTrue = getValue('environment.wind.angleTrueWater', signalkData)	
	angleApparent = getValue('environment.wind.angleApparent', signalkData)
	speedTrue = getValue('environment.wind.speedTrue', signalkData)	
	speedApparent = getValue('environment.wind.speedApparent', signalkData)
	
	// Draw the hands 
	if (angleTrue) {
		drawHand(ctx, angleTrue, radius, "#0000FF")
	}
	if (angleApparent) {
		drawHand(ctx, angleApparent, radius, "#C87800")
	}

	// Write the speeds
	ctx.font = radius*0.20 + "px Verdana";
	ctx.textBaseline="top";
	ctx.textAlign="center";

	if (speedApparent) {
		ctx.fillText(speedApparent + " kts", 0, radius * 0.1);
	}
	ctx.fillStyle = "#0000FF";
	if (speedTrue) {
		ctx.fillText(speedTrue + " kts", 0, radius * 0.3);
	}

}


function httpGetAsync(theUrl, callback) {
	// get a file through HTTP
	var xmlHttp = new XMLHttpRequest();
	xmlHttp.onreadystatechange = function() { 
		if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
			callback(xmlHttp.responseText);
	}
	xmlHttp.open("GET", theUrl, true); // true for asynchronous 
	xmlHttp.send(null);
}


var units = {}  // holds (path, units) tuplets, derived from the schema definition
var descriptions = {}  // holds (path, description) tuplets, derived from the schema definition

function onSchema(responseText) {
	// respond to the reception of a schema file
	schema = JSON.parse(responseText);
	//logDiv.innerHTML = JSON.stringify(schema, null, 2);

	function traverse(jsonObj, path) {
		// traverse the schema and store the units per path in the dictionary called 'units'
		if (jsonObj && typeof jsonObj == "object") {
			Object.entries(jsonObj).forEach(([key, value]) => {
				if (key == 'units' || key == 'description') {
					elements = path.split(".").splice(1); // split it up
					elements = elements.filter(function(value, index, arr){
						return (value != "meta" && value != "properties");   // cut out some elements
					}) 
					elements = elements.join(".");   // stick it together again
					if (key == 'units') 
						units[elements] = value;	// and poke it in the dictionary
					else
						descriptions[elements] = value
					//console.log(elements + " (" + value + ")");
				}
				else {
					traverse(value, path + "." + key);
				}
			});
		}
	}
	
	traverse (schema, "")
	//logDiv.innerHTML = JSON.stringify(units, null, 2) + JSON.stringify(descriptions, null, 2);
}


// get the schema definition file and let onSchema() do what needs to be done with it
httpGetAsync("http://" + mySignalkURL + "/signalk/v1/api/vessels/self/", onSchema);


// set up the stream of signalk deltas
var ws = new WebSocket("ws://" + mySignalkURL + "/signalk/v1/stream?subscribe=self");
ws.onclose = function() {
  console.log("ws close");
}

var signalkData = {};  // holds the signalk data

ws.onmessage = function(event) {
	json = JSON.parse(event.data);
	//logDiv.innerHTML = JSON.stringify(json, null, 2);
  
	for (var key in json) {
		if (key == "updates" && json[key][0]['$source'] != 'defaults') {
			timestamp = Date.parse(json[key][0]['timestamp']);
			source = json[key][0]['$source'];
			if (json[key][0]['$source'] != 'derived-data') {  
				try {
					source += " (" + json[key][0]['source']["sentence"] + ")";
				}
				catch {
					//logDiv.innerHTML = JSON.stringify(json, null, 2);
				}
			}
			values = json[key][0]['values'];
			// loop through all updated paths and store them in the signalk dictionary
			for (tuple in values) {
				path = values[tuple]['path'];
				value = values[tuple]['value'];
				entry = {timestamp, source, path, value};
				signalkData[path + source] = entry;  // store in the dictionary
				signalkData[path] = entry;  // store in the dictionary
			}
			
			// present the updated dictionary to the screen
			switch (presentation) {
				case 'table': 
					printSignalkTable(signalkData); break;
				case 'display':
					printSignalkDisplay(signalkData); break;
				case 'gauge':
					printSignalkGauge(signalkData); break;
			}
		} 
	}
}

</script>
</html>
