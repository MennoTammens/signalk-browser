<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>SignalK Data Browser</title>
  <style>
	tr:nth-child(odd) { background-color: #f2f2f2; }
  </style>
</head>
<body>
  <pre>
    <div id="data"/>
  </pre>
  <pre>
    <div id="log"/>
  </pre>
</body>

<script>

//
// Marco Bergman 2021
// Configure your signalk url:port below, like openplotter.pypilot.org:3000 or 10.10.10.1:3000
//
var mySignalkURL = "10.10.10.1:3000"

var dataDiv = document.getElementById('data');
var logDiv = document.getElementById('log');


function sortDictionary(dict) {
	// sort a dictionary based on the key
    var sorted = [];
    for(var key in dict) {
        sorted[sorted.length] = key;
    }
    sorted.sort();

    var tempDict = {};
    for(var i = 0; i < sorted.length; i++) {
        tempDict[sorted[i]] = dict[sorted[i]];
    }

    return tempDict;
}


function printSignalkTable(tableData) {
	// print the contents of a dictionary in the form of an HTML table
	var result = "<table border=0 width='100%'>";
	// sort the table first
	tableData = sortDictionary(tableData);
	for (key in tableData) {
		// get the value
		if (typeof(tableData[key]['value']) != 'object')
			value = tableData[key]['value'];
		else
			// show complex values as json
			value = JSON.stringify(tableData[key]['value']);
			
		// convert odd units
		unit = tableData[key]['unit'];
		if (unit == 'rad') {
			value = Math.round (value / Math.PI * 180, 0);
			unit = 'deg';
		}
		if (unit == 'm/s') {
			value = Math.round (value * 3600 / 1852, 1);
			unit = 'kts';
		}
		
		timestamp = tableData[key]['timestamp'].substring(11, 19);
		
		result += "<tr>";
		result += "<td>" + tableData[key]['path'] + "</td>";
		result += "<td>" + value + "</td>";
		result += "<td>" + unit + "</td>";
		result += "<td>" + tableData[key]['source'] + "</td>";
		result += "<td>" + timestamp + "</td>";
		result += "</tr>";
	}
	document.getElementById('data').innerHTML = result + "</table>";
}


function httpGetAsync(theUrl, callback) {
	// get a file through HTTP
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() { 
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
            callback(xmlHttp.responseText);
    }
    xmlHttp.open("GET", theUrl, true); // true for asynchronous 
    xmlHttp.send(null);
}


var units = {}  // holds (path, units) tuplets, derived from the schema definition

function onSchema(responseText) {
	// respond to the reception of a schema file
	schema = JSON.parse(responseText);
	//logDiv.innerHTML = JSON.stringify(schema, null, 2);

	function traverse(jsonObj, path) {
		// traverse the schema and store the units per path in the dictionary called 'units'
		if (jsonObj && typeof jsonObj == "object") {
			Object.entries(jsonObj).forEach(([key, value]) => {
				if (key == 'units') {
					elements = path.split(".").slice(3); // split it up, and cut off vessel + uri
					elements = elements.filter(function(value, index, arr){
						return (value != "meta" && value != "properties");   // cut out some elements
					}) 
					elements = elements.join(".");   // stick it together again
					units[elements] = value;    // and poke it in the dictionary
					//console.log(elements + " (" + value + ")");
				}
				else {
					traverse(value, path + "." + key);
				}
			});
		}
	}
	
	traverse (schema, "")
	//logDiv.innerHTML = JSON.stringify(units, null, 2);
}

// get the schema definition file and let onSchema() do what needs to be done with it
httpGetAsync("http://" + mySignalkURL + "/signalk/v1/api/", onSchema);


// set up the stream of signalk deltas
var ws = new WebSocket("ws://" + mySignalkURL + "/signalk/v1/stream?subscribe=self");
ws.onclose = function() {
  console.log("ws close");
}

var signalkData = {};  // holds the signalk data

ws.onmessage = function(event) {
	json = JSON.parse(event.data);
	//logDiv.innerHTML = JSON.stringify(json, null, 2);
  
	for (var key in json) {
		if (key == "updates" && json[key][0]['$source'] != 'defaults') {
			timestamp = json[key][0]['timestamp'];
			source = json[key][0]['$source'];
			if (json[key][0]['$source'] != 'derived-data') {  
				try {
					source += " (" + json[key][0]['source']["sentence"] + ")";
				}
				catch {
					//logDiv.innerHTML = JSON.stringify(json, null, 2);
				}
			}
			values = json[key][0]['values'];
			// loop through all updated paths and store them in the signalk dictionary
			for (tuple in values) {
				path = values[tuple]['path'];
				value = values[tuple]['value'];
				unit = units[path];  // resolve the units from the units dictionary that was derived from the schema file
				entry = {timestamp, source, path, value, unit};
				signalkData[path + source] = entry;  // store in the dictionary
			}
			
			// present the updated dictionary to the screen
			printSignalkTable(signalkData);
		} 
	}
}

</script>
</html>
